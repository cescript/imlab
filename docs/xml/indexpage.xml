<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>IMLAB Image Processing Library</title>
    <detaileddescription>
<para><image type="html" name="imlab.png"></image>
 IMLAB is an easy to use computer vision library written purely in C language. It is designed to be tiny, simple and brief yet self contained. No addtitional libraries is needed. Most of the fundemental operations on images, vectors, matrice and files are written pureley in C as header files which can be used sepeartely depending on your project specifics. Basically, IMLAB defines just a few very well known structures in order to keep the library readable and work comfortable. It has 5 main core project all under the imlab and all of them can be included or excluded from the main projet depending on your task. Although the library is written in C, it is designed to be look as object oriented manner so it is easy to read and it is easy to remember neccesarry functions for each operation. Each struct (will menteioned as class later) has its own operations and all operation belong to a Class is started with a class_name prefix. This type of access makes it possiple to use auto complete features in the editors and helps to find the realted functions easily.</para><para>IMLAB defines the following structure:<itemizedlist>
<listitem><para><ref refid="structvector__t" kindref="compound">vector_t</ref> is a vector container just like standart std vector in C++. <ref refid="structvector__t" kindref="compound">vector_t</ref> structure is a generic c-like array that can hold any type of variable in dynamically allocated memory. Just like the arrays, vector data is contigous in memory and can be accessed externally. Using a vector object is easy. Just decide the data type you need and call <ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref> to create a new vector object. The data type can be any C data types, additional names declared in stdint.h or structs created by the user. <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>*out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(uint32_t);</highlight></codeline>
</programlisting> The above code will create a vector object and set the initial length to zero and capacity to one. In order to add/remove element to vector <ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>/<ref refid="core_8h_1a268b0cbf4bfe212ad76135307957396a" kindref="member">vector_pop</ref> can be used. <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>values[12]<sp/>=<sp/>{0.0<sp/>0.1,<sp/>0.3,<sp/>0.5,<sp/>0.7,<sp/>0.9,<sp/>0.8,<sp/>0.6,<sp/>0.5,<sp/>0.4,<sp/>0.2,<sp/>0.0};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>in<sp/>this<sp/>loop<sp/>the<sp/>length<sp/>of<sp/>the<sp/>vector<sp/>will<sp/>automatically<sp/>increase<sp/>up<sp/>to<sp/>12.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>12;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>(out,<sp/>&amp;values[i]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> We can get the values from the vector with various methods. In the simplest case if we know the data type of the vector, we can obtain the data pointer and access the values via pointer just like standart c arrays. <programlisting><codeline><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*vector_data<sp/>=<sp/><ref refid="core_8h_1a17dd213399b468eaf01f9852a3ca36fc" kindref="member">data</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">,<sp/>out);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="core_8h_1aab37196bc836e9a106deac981b0a28e7" kindref="member">length</ref>(out);<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>val<sp/>=<sp/>vector_data[i];</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></listitem><listitem><para><ref refid="structmatrix__t" kindref="compound">matrix_t</ref> structure is a generic c-like array that can hold any type of variable in dynamically allocated memory. Just like the arrays and vectors, matrix data is contigous in memory and can be accessed externally. Similar to vector objects, matrix object is also resizable but you cannot increase the size of the matrix by pushing elements. The main advantage of the matrix object onto the standart arrays is that the matrix objects can hold two dimesional data in a simple way. Using matrix object the user inetarctions with the 2D array becomes easier and the code would be understandable.</para><para>Similar to the <ref refid="structvector__t" kindref="compound">vector_t</ref> structure <ref refid="structmatrix__t" kindref="compound">matrix_t</ref> structure can be created via matrix_create with any C data types, additional names declared in stdint.h or structs created by the user. <programlisting><codeline><highlight class="normal"><ref refid="structmatrix__t" kindref="compound">matrix_t</ref><sp/>*out<sp/>=<sp/><ref refid="core_8h_1ac161f0f0a945b552762c995c759c9f5a" kindref="member">matrix_create</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> The above code will create a matrix object and set the initial rows,cols and channels to zero. If you want to specify size to matrix just call: <programlisting><codeline><highlight class="normal"><ref refid="structmatrix__t" kindref="compound">matrix_t</ref><sp/>*out<sp/>=<sp/><ref refid="core_8h_1ac161f0f0a945b552762c995c759c9f5a" kindref="member">matrix_create</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">,<sp/>1024,<sp/>1024,<sp/>1);</highlight></codeline>
</programlisting> This call of the <ref refid="core_8h_1ac161f0f0a945b552762c995c759c9f5a" kindref="member">matrix_create</ref> will create a floating point data pointer and allocate 1024*1024*1*sizeof(float) byte memory on the memory. In order to access an element of a matrix <ref refid="core_8h_1ac6d6bb3c237a30597ffce28bc8a48254" kindref="member">at</ref> or <ref refid="core_8h_1a17dd213399b468eaf01f9852a3ca36fc" kindref="member">data</ref> functions could be used. <programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="core_8h_1a4e8f84fef6fd8d43a680c07df40aba25" kindref="member">rows</ref>(out);<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/><ref refid="core_8h_1aece6b4cf48e00b533a3a022244ad8206" kindref="member">cols</ref>(out);<sp/>j++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>val<sp/>=<sp/><ref refid="core_8h_1ac6d6bb3c237a30597ffce28bc8a48254" kindref="member">at</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">,<sp/>out,<sp/>i,j);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></listitem></itemizedlist>
</para><para>Links are generated automatically for webpages (like <ulink url="http://www.google.co.uk">http://www.google.co.uk</ulink>) and for structures, like BoxStruct_struct. For typedef-ed types use #BoxStruct. For functions, automatic links are generated when the parenthesis () follow the name of the function, like Box_The_Function_Name(). Alternatively, you can use #Box_The_Function_Name. <simplesect kind="return"><para><computeroutput>NULL</computeroutput> is always returned. </para></simplesect>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
