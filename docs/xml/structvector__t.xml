<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.5">
  <compounddef id="structvector__t" kind="struct" prot="public">
    <compoundname>vector_t</compoundname>
    <includes refid="core_8h" local="no">core.h</includes>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structvector__t_1a4128e69a4cc0324723ba54186f30ade5" prot="public" static="no" mutable="no">
        <type>struct imlab_type_t *</type>
        <definition>struct imlab_type_t* vector_t::_type</definition>
        <argsstring></argsstring>
        <name>_type</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" line="510" column="1" bodyfile="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" bodystart="510" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structvector__t_1a328bcc8201f1ed6ec2121f8968c4b2b9" prot="public" static="no" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t vector_t::_capacity</definition>
        <argsstring></argsstring>
        <name>_capacity</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" line="510" column="1" bodyfile="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" bodystart="510" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structvector__t_1a44d00ddfd0d90c57152d8441227903ca" prot="public" static="no" mutable="no">
        <type>uint32_t</type>
        <definition>uint32_t vector_t::_length</definition>
        <argsstring></argsstring>
        <name>_length</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" line="510" column="1" bodyfile="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" bodystart="510" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structvector__t_1a731d1e4f131c29a5dc6e17882360e7ca" prot="public" static="no" mutable="no">
        <type>void *</type>
        <definition>void* vector_t::_data</definition>
        <argsstring></argsstring>
        <name>_data</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" line="510" column="1" bodyfile="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" bodystart="510" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="structvector__t" kindref="compound">vector_t</ref> is a vector container just like standart std vector in C++. </para>    </briefdescription>
    <detaileddescription>
<para><ref refid="structvector__t" kindref="compound">vector_t</ref> structure is a generic c-like array that can hold any type of variable in dynamically allocated memory. Just like the arrays, vector data is contigous in memory and can be accessed externally. The main advantage of the vector object onto the standart arrays is that the vector objects can dynamically grow or shrink. This type of needs can be accomplished via realloc and memcpy opeartions in standart C and as expected IMLAB is also doing these operations in clean and brief function calls and keeps everything about the vector in tiny and tidy <ref refid="structvector__t" kindref="compound">vector_t</ref> structure.</para><para><simplesect kind="warning"><para>It is important to note that adding/deleting or changing an element or member of a vector should be done over the dedicated functions. Setting an element of the vector over data pointer does not change the length nor the capacity of the vector. This could cause memory overflow or data overwriting.</para></simplesect>
IMLAB defines the following functions for vector objects:<itemizedlist>
<listitem><para><ref refid="core_8h_1aab37196bc836e9a106deac981b0a28e7" kindref="member">length</ref> : returns the length of the vector</para></listitem><listitem><para><ref refid="core_8h_1a356cce4442240ba05926d09fc49cfa20" kindref="member">capacity</ref> : returns the capacity of the vector</para></listitem><listitem><para><ref refid="core_8h_1a9b5423f6356f19bde71fc706337bbc2d" kindref="member">vdata</ref> / <ref refid="core_8h_1a17dd213399b468eaf01f9852a3ca36fc" kindref="member">data</ref> : returns the pointer to the data of the vector</para></listitem><listitem><para><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref> : constructor function and zero initializer</para></listitem><listitem><para><ref refid="core_8h_1adaeadebefce3d6e4d6e9e68662da874f" kindref="member">vector_resize</ref> : change the size of the data holded in container</para></listitem><listitem><para><ref refid="core_8h_1a790a513601c408b9b76cf8a6228a2213" kindref="member">vector_free</ref> : destructor functions</para></listitem><listitem><para><ref refid="core_8h_1a1a3e7877bd0c2ed2e671a3b613913dd3" kindref="member">vector_fill</ref> : set the struct with a constant value</para></listitem><listitem><para><ref refid="core_8h_1a9d0bb0a950b4bc487c596f6b86ddaa46" kindref="member">vector_permute</ref> : permute the entries of the vector with the given index list</para></listitem><listitem><para><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref> : push an instance to the vector, if there is no space, creates one</para></listitem><listitem><para><ref refid="core_8h_1a268b0cbf4bfe212ad76135307957396a" kindref="member">vector_pop</ref> : get an index from the vector and remove it from the array</para></listitem><listitem><para><ref refid="core_8h_1a40c40d599551f38a807ce500a8da634c" kindref="member">vector_read</ref> : loads the vector struct from the hard drive (uncompress data)</para></listitem><listitem><para><ref refid="core_8h_1a382e5a7fe0f9fc241ecd3304f5853517" kindref="member">vector_write</ref> : saves the type struct to the hard drive (compress data)</para></listitem></itemizedlist>
</para><para>Using a vector object is easy. Just decide the data type you need and call <ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref> to create a new vector object. The data type can be any C data types, additional names declared in stdint.h or structs created by the user. <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(uint32_t);</highlight></codeline>
</programlisting> The above code will create a vector object and set the initial length to zero and capacity to one. If you want to specify an initial capacity to vector just call: <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">,<sp/>1024);</highlight></codeline>
</programlisting> This call of the <ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref> will create a floating point data pointer and allocate 1024*sizeof(float) byte memory on the memory. Since the vector object could be enlarged or shrinked, setting an initial capacity will increase the time efficincy for large vectors. It is also possible to create a vector from an existing one or from c pointers. In this case the third argument should be the pointer to the data: <programlisting><codeline><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>numbers[9]<sp/>=<sp/>{1,2,3,<sp/>4,5,6,<sp/>7,8,9};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">,<sp/>9,<sp/>numbers);</highlight></codeline>
</programlisting> In this case vector_create will allocate memory and do <bold>memcpy</bold> operation on the given pointer. To create a vector which has initially constant values you can use <ref refid="core_8h_1a1a3e7877bd0c2ed2e671a3b613913dd3" kindref="member">vector_fill</ref> function: <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(uint16_t,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal">uint16_t<sp/>val<sp/>=<sp/>12;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="core_8h_1a1a3e7877bd0c2ed2e671a3b613913dd3" kindref="member">vector_fill</ref>(&amp;out,<sp/>&amp;val);</highlight></codeline>
</programlisting> In order to add/remove element to vector <ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>/<ref refid="core_8h_1a268b0cbf4bfe212ad76135307957396a" kindref="member">vector_pop</ref> can be used. <programlisting><codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>out<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>values[12]<sp/>=<sp/>{0.0<sp/>0.1,<sp/>0.3,<sp/>0.5,<sp/>0.7,<sp/>0.9,<sp/>0.8,<sp/>0.6,<sp/>0.5,<sp/>0.4,<sp/>0.2,<sp/>0.0};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>in<sp/>this<sp/>loop<sp/>the<sp/>length<sp/>of<sp/>the<sp/>vector<sp/>will<sp/>automatically<sp/>increase<sp/>up<sp/>to<sp/>12.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>12;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>(&amp;out,<sp/>&amp;values[i]);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> We can get the values from the vector with various methods. In the simplest case if we know the data type of the vector, we can obtain the data pointer and access the values via pointer just like standart c arrays. <programlisting><codeline><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>*vector_data<sp/>=<sp/><ref refid="core_8h_1a9b5423f6356f19bde71fc706337bbc2d" kindref="member">vdata</ref>(out,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="core_8h_1aab37196bc836e9a106deac981b0a28e7" kindref="member">length</ref>(out);<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>val<sp/>=<sp/>vector_data[i];</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> Or we can access the data elemnt using the special function <ref refid="core_8h_1ac6d6bb3c237a30597ffce28bc8a48254" kindref="member">at</ref> as follows: <programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/><ref refid="core_8h_1aab37196bc836e9a106deac981b0a28e7" kindref="member">length</ref>(out);<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>val<sp/>=<sp/><ref refid="core_8h_1ac6d6bb3c237a30597ffce28bc8a48254" kindref="member">at</ref>(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal">,<sp/>out,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>You can also use the vector container with the custom defined structures. Here is an example of how to use vector container with the custom structures.</para><para><programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>uint32_t<sp/>id;</highlight></codeline>
<codeline><highlight class="normal"><sp/>uint32_t<sp/>birthday;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>*people<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>person);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>var<sp/>=<sp/>{1,<sp/>1990};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>(people,<sp/>&amp;var);</highlight></codeline>
<codeline><highlight class="normal"><sp/>...</highlight></codeline>
<codeline><highlight class="normal">vector_free(&amp;people);</highlight></codeline>
</programlisting> The above code will generate a person structure and create a vector container for that structure. And push an instance of the structure into the people vector. And clear the vector after all the operations are done.</para><para><simplesect kind="warning"><para>If the custom type has any dynamically allocated memory pointer an additional care must be taken in order to avoid memory leaks.</para></simplesect>
If the structure contains any pointer member than <ref refid="core_8h_1ad0c77c70c8d497343a0a46edb6b5a366" kindref="member">matrix_free</ref> will not free the memory allocated for the member and result in memory leakage. Lets look at the problem with a similar example; <programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>uint32_t<sp/>id;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*name;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>*people<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>person,<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>var<sp/>=<sp/>{1,<sp/>strdup(</highlight><highlight class="stringliteral">&quot;any<sp/>dynamically<sp/>allocated<sp/>memory<sp/>inside<sp/>the<sp/>custom<sp/>type<sp/>will<sp/>cause<sp/>memory<sp/>leak&quot;</highlight><highlight class="normal">)};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>(people,<sp/>&amp;var);</highlight></codeline>
<codeline><highlight class="normal"><sp/>...</highlight></codeline>
<codeline><highlight class="normal">vector_free(&amp;people);</highlight></codeline>
</programlisting> In this case the size of the structure is 40 byte but freeing 40 byte will only remove the memory of id and name variable but not the memory allocated for the name pointer. The only way to completely clean the object is first freeing the name pointer and than calling the <ref refid="core_8h_1a790a513601c408b9b76cf8a6228a2213" kindref="member">vector_free</ref>.</para><para>In order to make this process simple, IMLAB defines a function called <ref refid="core_8h_1a2ed78ff337337c3e7d13b34cd35a54fa" kindref="member">vector_destructor</ref>. This function is taking a destructor function for the created type and during <ref refid="core_8h_1a790a513601c408b9b76cf8a6228a2213" kindref="member">vector_free</ref> IMLAB first calls the given destructor function and then free up the memory.</para><para><programlisting><codeline><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>uint32_t<sp/>id;</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*name;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>destructor<sp/>for<sp/>the<sp/>person<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>person_destructor(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*elements,<sp/>uint32_t<sp/>plength)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">*people<sp/>=<sp/>elements;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/>plength;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(people[i].name);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"><ref refid="structvector__t" kindref="compound">vector_t</ref><sp/>*people<sp/>=<sp/><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref>(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/>person,<sp/>50);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>set<sp/>destructor<sp/>for<sp/>the<sp/>contained<sp/>type</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="core_8h_1a2ed78ff337337c3e7d13b34cd35a54fa" kindref="member">vector_destructor</ref>(people,<sp/><sp/>person_destructor);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">person<sp/>var<sp/>=<sp/>{1,<sp/>strdup(</highlight><highlight class="stringliteral">&quot;in<sp/>this<sp/>case<sp/>this<sp/>memory<sp/>will<sp/>be<sp/>released<sp/>by<sp/>the<sp/>user<sp/>defined<sp/>destructor:<sp/>person_destructor()&quot;</highlight><highlight class="normal">)};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref>(people,<sp/>&amp;var);</highlight></codeline>
<codeline><highlight class="normal"><sp/>...</highlight></codeline>
<codeline><highlight class="normal">vector_free(&amp;people);</highlight></codeline>
</programlisting></para><para><simplesect kind="see"><para><ref refid="core_8h_1a160b0d4b8d0836eda9a50bfa71514de8" kindref="member">vector_create</ref> </para><simplesectsep/><para><ref refid="core_8h_1adaeadebefce3d6e4d6e9e68662da874f" kindref="member">vector_resize</ref> </para><simplesectsep/><para><ref refid="core_8h_1a790a513601c408b9b76cf8a6228a2213" kindref="member">vector_free</ref> </para><simplesectsep/><para><ref refid="core_8h_1a1a3e7877bd0c2ed2e671a3b613913dd3" kindref="member">vector_fill</ref> </para><simplesectsep/><para><ref refid="core_8h_1a9d0bb0a950b4bc487c596f6b86ddaa46" kindref="member">vector_permute</ref> </para><simplesectsep/><para><ref refid="core_8h_1af09d64899cb5a7eb37453f495cc929f9" kindref="member">vector_push</ref> </para><simplesectsep/><para><ref refid="core_8h_1a268b0cbf4bfe212ad76135307957396a" kindref="member">vector_pop</ref> </para><simplesectsep/><para><ref refid="core_8h_1a40c40d599551f38a807ce500a8da634c" kindref="member">vector_read</ref> </para><simplesectsep/><para><ref refid="core_8h_1a382e5a7fe0f9fc241ecd3304f5853517" kindref="member">vector_write</ref> </para></simplesect>
</para>    </detaileddescription>
    <location file="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" line="510" column="1" bodyfile="C:/Users/cescript/CLionProjects/imlab/include/header/core.h" bodystart="510" bodyend="510"/>
    <listofallmembers>
      <member refid="structvector__t_1a328bcc8201f1ed6ec2121f8968c4b2b9" prot="public" virt="non-virtual"><scope>vector_t</scope><name>_capacity</name></member>
      <member refid="structvector__t_1a731d1e4f131c29a5dc6e17882360e7ca" prot="public" virt="non-virtual"><scope>vector_t</scope><name>_data</name></member>
      <member refid="structvector__t_1a44d00ddfd0d90c57152d8441227903ca" prot="public" virt="non-virtual"><scope>vector_t</scope><name>_length</name></member>
      <member refid="structvector__t_1a4128e69a4cc0324723ba54186f30ade5" prot="public" virt="non-virtual"><scope>vector_t</scope><name>_type</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
